// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String?
  emailVerified DateTime?
  image         String?
  role          String    @default("student") // "student", "teacher", "admin"
  isApproved    Boolean   @default(true) // Teachers need approval, students auto-approved
  approvedBy    String?
  approvedAt    DateTime?
  isActive      Boolean   @default(true) // Can be disabled by admin
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  quizResults        QuizResult[]
  quizzes            Quiz[]
  settings           UserSettings?
  teacherClasses     Class[]            @relation("TeacherClasses")
  classMembers       ClassMember[]
  teacherApplication TeacherApplication?
  adminLogs          AdminLog[]         @relation("AdminActions")
  scoreModifications ScoreModification[] @relation("ModifiedBy")
  retakesGranted     QuizRetake[]       @relation("RetakeGrantedBy")
  correctionsApplied QuestionCorrection[] @relation("CorrectionAppliedBy")

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

model Quiz {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  questions   Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  results     QuizResult[]

  @@index([userId])
  @@index([createdAt])
}

model QuizResult {
  id              String   @id @default(cuid())
  userId          String
  quizId          String
  score           Int
  totalQuestions  Int
  percentage      Float
  userAnswers     Json
  timeLimit       Int?
  timeTaken       Int?
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  quiz            Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([quizId])
  @@index([createdAt])
  @@map("quiz_results")
}

model UserSettings {
  id                  String   @id @default(cuid())
  userId              String   @unique
  theme               String   @default("system")
  defaultTimeLimit    Int      @default(30)
  showExplanations    Boolean  @default(true)
  emailNotifications  Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ==========================================
// CLASSROOM FEATURE MODELS
// ==========================================

model Class {
  id             String   @id @default(cuid())
  name           String
  description    String?
  code           String   @unique
  teacherId      String
  maxRetakes     Int      @default(5) // Overall retakes allowed for all students
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  teacher     User            @relation("TeacherClasses", fields: [teacherId], references: [id], onDelete: Cascade)
  members     ClassMember[]
  quizzes     ClassQuiz[]
  invitations ClassInvitation[]

  @@index([teacherId])
  @@index([code])
  @@map("classes")
}

model ClassMember {
  id        String   @id @default(cuid())
  classId   String
  userId    String
  role      String   @default("student") // "student" or "assistant"
  joinedAt  DateTime @default(now())

  class     Class              @relation(fields: [classId], references: [id], onDelete: Cascade)
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  attempts  ClassQuizAttempt[]
  retakes   QuizRetake[]

  @@unique([classId, userId])
  @@index([classId])
  @@index([userId])
  @@map("class_members")
}

model ClassQuiz {
  id               String   @id @default(cuid())
  classId          String
  name             String
  description      String?
  questions        Json
  duration         Int
  startTime        DateTime
  endTime          DateTime
  showResults      Boolean  @default(true)
  shuffleQuestions Boolean  @default(false)
  allowRetakes     Boolean  @default(true) // Whether retakes can be granted
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  class       Class                @relation(fields: [classId], references: [id], onDelete: Cascade)
  attempts    ClassQuizAttempt[]
  retakes     QuizRetake[]
  corrections QuestionCorrection[]

  @@index([classId])
  @@index([startTime])
  @@index([endTime])
  @@map("class_quizzes")
}

model ClassQuizAttempt {
  id              String   @id @default(cuid())
  classQuizId     String
  memberId        String
  attemptNumber   Int      @default(1) // 1 for first, 2+ for retakes
  score           Int?
  totalQuestions  Int
  percentage      Float?
  userAnswers     Json?
  startedAt       DateTime @default(now())
  submittedAt     DateTime?
  autoSubmitted   Boolean  @default(false)
  status          String   @default("in_progress") // "in_progress", "submitted"
  isRetake        Boolean  @default(false)
  retakeId        String?  // Reference to QuizRetake if this is a retake

  classQuiz          ClassQuiz           @relation(fields: [classQuizId], references: [id], onDelete: Cascade)
  member             ClassMember         @relation(fields: [memberId], references: [id], onDelete: Cascade)
  scoreModifications ScoreModification[]

  @@index([classQuizId])
  @@index([memberId])
  @@index([status])
  @@map("class_quiz_attempts")
}

model ClassInvitation {
  id          String   @id @default(cuid())
  classId     String
  email       String
  status      String   @default("pending")
  token       String   @unique @default(cuid())
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  class       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)

  @@unique([classId, email])
  @@index([classId])
  @@index([email])
  @@index([token])
  @@index([status])
  @@map("class_invitations")
}

// ==========================================
// RETAKE & CORRECTION MODELS
// ==========================================

model QuizRetake {
  id            String   @id @default(cuid())
  classQuizId   String
  memberId      String?  // Null for class-wide retake, set for individual
  type          String   // "individual" or "class_wide"
  grantedById   String
  grantedAt     DateTime @default(now())
  expiresAt     DateTime
  reason        String?
  used          Boolean  @default(false)
  usedAt        DateTime?

  classQuiz  ClassQuiz    @relation(fields: [classQuizId], references: [id], onDelete: Cascade)
  member     ClassMember? @relation(fields: [memberId], references: [id], onDelete: Cascade)
  grantedBy  User         @relation("RetakeGrantedBy", fields: [grantedById], references: [id])

  @@index([classQuizId])
  @@index([memberId])
  @@index([type])
  @@map("quiz_retakes")
}

model QuestionCorrection {
  id            String   @id @default(cuid())
  classQuizId   String
  questionId    Int      // ID of the question in the quiz JSON
  bonusPoints   Int      @default(1)
  reason        String
  appliedById   String
  appliedAt     DateTime @default(now())

  classQuiz  ClassQuiz @relation(fields: [classQuizId], references: [id], onDelete: Cascade)
  appliedBy  User      @relation("CorrectionAppliedBy", fields: [appliedById], references: [id])

  @@unique([classQuizId, questionId])
  @@index([classQuizId])
  @@map("question_corrections")
}

model ScoreModification {
  id              String   @id @default(cuid())
  attemptId       String
  originalScore   Int
  newScore        Int
  reason          String
  modifiedById    String
  modifiedAt      DateTime @default(now())

  attempt    ClassQuizAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  modifiedBy User             @relation("ModifiedBy", fields: [modifiedById], references: [id])

  @@index([attemptId])
  @@map("score_modifications")
}

// ==========================================
// ADMIN & TEACHER APPLICATION MODELS
// ==========================================

model TeacherApplication {
  id          String   @id @default(cuid())
  userId      String   @unique
  institution String
  reason      String
  status      String   @default("pending") // "pending", "approved", "rejected"
  reviewedBy  String?
  reviewedAt  DateTime?
  reviewNote  String?
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@map("teacher_applications")
}

model ApprovedDomain {
  id        String   @id @default(cuid())
  domain    String   @unique // e.g., "@university.edu"
  note      String?  // Why this domain is approved
  addedBy   String
  addedAt   DateTime @default(now())

  @@map("approved_domains")
}

model AdminLog {
  id          String   @id @default(cuid())
  adminId     String
  action      String   // "approve_teacher", "reject_teacher", "change_role", "modify_score", etc.
  targetType  String   // "user", "class", "quiz", "attempt"
  targetId    String
  details     Json?
  createdAt   DateTime @default(now())

  admin       User     @relation("AdminActions", fields: [adminId], references: [id])

  @@index([adminId])
  @@index([action])
  @@index([targetType])
  @@index([createdAt])
  @@map("admin_logs")
}

// ==========================================
// SYSTEM SETTINGS
// ==========================================

model SystemSettings {
  id                  String   @id @default("system")
  siteName            String   @default("Quiz Platform")
  allowRegistration   Boolean  @default(true)
  requireEmailVerify  Boolean  @default(true)
  updatedAt           DateTime @updatedAt

  @@map("system_settings")
}
